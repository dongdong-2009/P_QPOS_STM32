; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210e-eval\stm32f10x_i2c.o --asm_dir=.\STM3210E-EVAL\ --list_dir=.\STM3210E-EVAL\ --depend=.\stm3210e-eval\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210E_EVAL -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL --omf_browse=.\stm3210e-eval\stm32f10x_i2c.crf ..\..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;845      */
;;;846    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L1.12|
;;;847    {
;;;848      /* Check the parameters */
;;;849      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;850      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;851      if (NewState != DISABLE)
;;;852      {
;;;853        /* Enable the selected I2C ARP */
;;;854        I2Cx->CR1 |= CR1_ENARP_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420210          ORR      r2,r2,#0x10
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L1.22|
                  |L1.12|
;;;855      }
;;;856      else
;;;857      {
;;;858        /* Disable the selected I2C ARP */
;;;859        I2Cx->CR1 &= CR1_ENARP_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L1.22|
;;;860      }
;;;861    }
000016  4770              BX       lr
;;;862    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;447      */
;;;448    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L2.12|
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;452      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;453      if (NewState != DISABLE)
;;;454      {
;;;455        /* Enable the acknowledgement */
;;;456        I2Cx->CR1 |= CR1_ACK_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4426280          ORR      r2,r2,#0x400
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L2.22|
                  |L2.12|
;;;457      }
;;;458      else
;;;459      {
;;;460        /* Disable the acknowledgement */
;;;461        I2Cx->CR1 &= CR1_ACK_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f33ff          MOV      r3,#0xfbff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L2.22|
;;;462      }
;;;463    }
000016  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;808      */
;;;809    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;810    {
;;;811      /* Check the parameters */
;;;812      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;813      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;814      if (NewState != DISABLE)
;;;815      {
;;;816        /* Enable the selected I2C PEC calculation */
;;;817        I2Cx->CR1 |= CR1_ENPEC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420220          ORR      r2,r2,#0x20
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L3.22|
                  |L3.12|
;;;818      }
;;;819      else
;;;820      {
;;;821        /* Disable the selected I2C PEC calculation */
;;;822        I2Cx->CR1 &= CR1_ENPEC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L3.22|
;;;823      }
;;;824    }
000016  4770              BX       lr
;;;825    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1035     */
;;;1036   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  b570              PUSH     {r4-r6,lr}
;;;1037   {
000002  4602              MOV      r2,r0
;;;1038     uint32_t lastevent = 0;
000004  2400              MOVS     r4,#0
;;;1039     uint32_t flag1 = 0, flag2 = 0;
000006  2500              MOVS     r5,#0
000008  2300              MOVS     r3,#0
;;;1040     ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;1041   
;;;1042     /* Check the parameters */
;;;1043     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1044     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1045   
;;;1046     /* Read the I2Cx status register */
;;;1047     flag1 = I2Cx->SR1;
00000c  8a95              LDRH     r5,[r2,#0x14]
;;;1048     flag2 = I2Cx->SR2;
00000e  8b13              LDRH     r3,[r2,#0x18]
;;;1049     flag2 = flag2 << 16;
000010  041b              LSLS     r3,r3,#16
;;;1050   
;;;1051     /* Get the last event value from I2C status register */
;;;1052     lastevent = (flag1 | flag2) & FLAG_Mask;
000012  ea450603          ORR      r6,r5,r3
000016  f026447f          BIC      r4,r6,#0xff000000
;;;1053   
;;;1054     /* Check whether the last event contains the I2C_EVENT */
;;;1055     if ((lastevent & I2C_EVENT) == I2C_EVENT)
00001a  ea040601          AND      r6,r4,r1
00001e  428e              CMP      r6,r1
000020  d101              BNE      |L4.38|
;;;1056     {
;;;1057       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1058       status = SUCCESS;
000022  2001              MOVS     r0,#1
000024  e000              B        |L4.40|
                  |L4.38|
;;;1059     }
;;;1060     else
;;;1061     {
;;;1062       /* ERROR: last event is different from I2C_EVENT */
;;;1063       status = ERROR;
000026  2000              MOVS     r0,#0
                  |L4.40|
;;;1064     }
;;;1065     /* Return status */
;;;1066     return status;
;;;1067   }
000028  bd70              POP      {r4-r6,pc}
;;;1068   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1217     */
;;;1218   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  2200              MOVS     r2,#0
;;;1219   {
;;;1220     uint32_t flagpos = 0;
;;;1221     /* Check the parameters */
;;;1222     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1223     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1224     /* Get the I2C flag position */
;;;1225     flagpos = I2C_FLAG & FLAG_Mask;
000002  f021427f          BIC      r2,r1,#0xff000000
;;;1226     /* Clear the selected I2C flag */
;;;1227     I2Cx->SR1 = (uint16_t)~flagpos;
000006  43d3              MVNS     r3,r2
000008  8283              STRH     r3,[r0,#0x14]
;;;1228   }
00000a  4770              BX       lr
;;;1229   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1312     */
;;;1313   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  2200              MOVS     r2,#0
;;;1314   {
;;;1315     uint32_t flagpos = 0;
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1318     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1319     /* Get the I2C flag position */
;;;1320     flagpos = I2C_IT & FLAG_Mask;
000002  f021427f          BIC      r2,r1,#0xff000000
;;;1321     /* Clear the selected I2C flag */
;;;1322     I2Cx->SR1 = (uint16_t)~flagpos;
000006  43d3              MVNS     r3,r2
000008  8283              STRH     r3,[r0,#0x14]
;;;1323   }
00000a  4770              BX       lr
;;;1324   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;327      */
;;;328    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L7.12|
;;;329    {
;;;330      /* Check the parameters */
;;;331      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;332      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;333      if (NewState != DISABLE)
;;;334      {
;;;335        /* Enable the selected I2C peripheral */
;;;336        I2Cx->CR1 |= CR1_PE_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L7.22|
                  |L7.12|
;;;337      }
;;;338      else
;;;339      {
;;;340        /* Disable the selected I2C peripheral */
;;;341        I2Cx->CR1 &= CR1_PE_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L7.22|
;;;342      }
;;;343    }
000016  4770              BX       lr
;;;344    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;351      */
;;;352    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;353    {
;;;354      /* Check the parameters */
;;;355      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;356      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;357      if (NewState != DISABLE)
;;;358      {
;;;359        /* Enable the selected I2C DMA requests */
;;;360        I2Cx->CR2 |= CR2_DMAEN_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f4426200          ORR      r2,r2,#0x800
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;361      }
;;;362      else
;;;363      {
;;;364        /* Disable the selected I2C DMA requests */
;;;365        I2Cx->CR2 &= CR2_DMAEN_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f24f73ff          MOV      r3,#0xf7ff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;366      }
;;;367    }
000016  4770              BX       lr
;;;368    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;375      */
;;;376    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L9.12|
;;;377    {
;;;378      /* Check the parameters */
;;;379      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;380      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;381      if (NewState != DISABLE)
;;;382      {
;;;383        /* Next DMA transfer is the last transfer */
;;;384        I2Cx->CR2 |= CR2_LAST_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L9.22|
                  |L9.12|
;;;385      }
;;;386      else
;;;387      {
;;;388        /* Next DMA transfer is not the last transfer */
;;;389        I2Cx->CR2 &= CR2_LAST_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L9.22|
;;;390      }
;;;391    }
000016  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;167      */
;;;168    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;169    {
000002  4604              MOV      r4,r0
;;;170      /* Check the parameters */
;;;171      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;172    
;;;173      if (I2Cx == I2C1)
000004  480b              LDR      r0,|L10.52|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L10.30|
;;;174      {
;;;175        /* Enable I2C1 reset state */
;;;176        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0548              LSLS     r0,r1,#21
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;177        /* Release I2C1 from reset state */
;;;178        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f44f1000          MOV      r0,#0x200000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e008              B        |L10.48|
                  |L10.30|
;;;179      }
;;;180      else
;;;181      {
;;;182        /* Enable I2C2 reset state */
;;;183        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0588              LSLS     r0,r1,#22
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;184        /* Release I2C2 from reset state */
;;;185        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
000026  2100              MOVS     r1,#0
000028  f44f0080          MOV      r0,#0x400000
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L10.48|
;;;186      }
;;;187    }
000030  bd10              POP      {r4,pc}
;;;188    
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x40005400

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;497      */
;;;498    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L11.12|
;;;499    {
;;;500      /* Check the parameters */
;;;501      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;502      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;503      if (NewState != DISABLE)
;;;504      {
;;;505        /* Enable dual addressing mode */
;;;506        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L11.22|
                  |L11.12|
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Disable dual addressing mode */
;;;511        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L11.22|
;;;512      }
;;;513    }
000016  4770              BX       lr
;;;514    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;895      */
;;;896    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;897    {
;;;898      /* Check the parameters */
;;;899      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;900      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;901      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000004  d005              BEQ      |L12.18|
;;;902      {
;;;903        /* I2C fast mode Tlow/Thigh=2 */
;;;904        I2Cx->CCR &= I2C_DutyCycle_2;
000006  8b82              LDRH     r2,[r0,#0x1c]
000008  f64b73ff          MOV      r3,#0xbfff
00000c  401a              ANDS     r2,r2,r3
00000e  8382              STRH     r2,[r0,#0x1c]
000010  e003              B        |L12.26|
                  |L12.18|
;;;905      }
;;;906      else
;;;907      {
;;;908        /* I2C fast mode Tlow/Thigh=16/9 */
;;;909        I2Cx->CCR |= I2C_DutyCycle_16_9;
000012  8b82              LDRH     r2,[r0,#0x1c]
000014  f4424280          ORR      r2,r2,#0x4000
000018  8382              STRH     r2,[r0,#0x1c]
                  |L12.26|
;;;910      }
;;;911    }
00001a  4770              BX       lr
;;;912    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;521      */
;;;522    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;523    {
;;;524      /* Check the parameters */
;;;525      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;526      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;527      if (NewState != DISABLE)
;;;528      {
;;;529        /* Enable generall call */
;;;530        I2Cx->CR1 |= CR1_ENGC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420240          ORR      r2,r2,#0x40
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;531      }
;;;532      else
;;;533      {
;;;534        /* Disable generall call */
;;;535        I2Cx->CR1 &= CR1_ENGC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f73bf          MOV      r3,#0xffbf
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L13.22|
;;;536      }
;;;537    }
000016  4770              BX       lr
;;;538    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;399      */
;;;400    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L14.12|
;;;401    {
;;;402      /* Check the parameters */
;;;403      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;404      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;405      if (NewState != DISABLE)
;;;406      {
;;;407        /* Generate a START condition */
;;;408        I2Cx->CR1 |= CR1_START_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427280          ORR      r2,r2,#0x100
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L14.22|
                  |L14.12|
;;;409      }
;;;410      else
;;;411      {
;;;412        /* Disable the START condition generation */
;;;413        I2Cx->CR1 &= CR1_START_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f63ff          MOV      r3,#0xfeff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L14.22|
;;;414      }
;;;415    }
000016  4770              BX       lr
;;;416    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;423      */
;;;424    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L15.12|
;;;425    {
;;;426      /* Check the parameters */
;;;427      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;428      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;429      if (NewState != DISABLE)
;;;430      {
;;;431        /* Generate a STOP condition */
;;;432        I2Cx->CR1 |= CR1_STOP_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4427200          ORR      r2,r2,#0x200
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L15.22|
                  |L15.12|
;;;433      }
;;;434      else
;;;435      {
;;;436        /* Disable the STOP condition generation */
;;;437        I2Cx->CR1 &= CR1_STOP_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f53ff          MOV      r3,#0xfdff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L15.22|
;;;438      }
;;;439    }
000016  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1138     */
;;;1139   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b50c              PUSH     {r2,r3,lr}
;;;1140   {
000002  4602              MOV      r2,r0
;;;1141     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1142     __IO uint32_t i2creg = 0, i2cxbase = 0;
000006  2300              MOVS     r3,#0
000008  9301              STR      r3,[sp,#4]
00000a  9300              STR      r3,[sp,#0]
;;;1143   
;;;1144     /* Check the parameters */
;;;1145     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1146     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1147   
;;;1148     /* Get the I2Cx peripheral base address */
;;;1149     i2cxbase = (uint32_t)I2Cx;
00000c  9200              STR      r2,[sp,#0]
;;;1150     
;;;1151     /* Read flag register index */
;;;1152     i2creg = I2C_FLAG >> 28;
00000e  0f0b              LSRS     r3,r1,#28
000010  9301              STR      r3,[sp,#4]
;;;1153     
;;;1154     /* Get bit[23:0] of the flag */
;;;1155     I2C_FLAG &= FLAG_Mask;
000012  f021417f          BIC      r1,r1,#0xff000000
;;;1156     
;;;1157     if(i2creg != 0)
000016  9b01              LDR      r3,[sp,#4]
000018  b11b              CBZ      r3,|L16.34|
;;;1158     {
;;;1159       /* Get the I2Cx SR1 register address */
;;;1160       i2cxbase += 0x14;
00001a  9b00              LDR      r3,[sp,#0]
00001c  3314              ADDS     r3,r3,#0x14
00001e  9300              STR      r3,[sp,#0]
000020  e003              B        |L16.42|
                  |L16.34|
;;;1161     }
;;;1162     else
;;;1163     {
;;;1164       /* Flag in I2Cx SR2 Register */
;;;1165       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
000022  0c09              LSRS     r1,r1,#16
;;;1166       /* Get the I2Cx SR2 register address */
;;;1167       i2cxbase += 0x18;
000024  9b00              LDR      r3,[sp,#0]
000026  3318              ADDS     r3,r3,#0x18
000028  9300              STR      r3,[sp,#0]
                  |L16.42|
;;;1168     }
;;;1169     
;;;1170     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00002a  9b00              LDR      r3,[sp,#0]
00002c  681b              LDR      r3,[r3,#0]
00002e  400b              ANDS     r3,r3,r1
000030  b10b              CBZ      r3,|L16.54|
;;;1171     {
;;;1172       /* I2C_FLAG is set */
;;;1173       bitstatus = SET;
000032  2001              MOVS     r0,#1
000034  e000              B        |L16.56|
                  |L16.54|
;;;1174     }
;;;1175     else
;;;1176     {
;;;1177       /* I2C_FLAG is reset */
;;;1178       bitstatus = RESET;
000036  2000              MOVS     r0,#0
                  |L16.56|
;;;1179     }
;;;1180     
;;;1181     /* Return the I2C_FLAG status */
;;;1182     return  bitstatus;
;;;1183   }
000038  bd0c              POP      {r2,r3,pc}
;;;1184   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1251     */
;;;1252   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1253   {
000002  4602              MOV      r2,r0
;;;1254     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1255     uint32_t enablestatus = 0;
000006  2300              MOVS     r3,#0
;;;1256   
;;;1257     /* Check the parameters */
;;;1258     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1259     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1260   
;;;1261     /* Check if the interrupt source is enabled or not */
;;;1262     enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
000008  8894              LDRH     r4,[r2,#4]
00000a  f00165e0          AND      r5,r1,#0x7000000
00000e  ea044315          AND      r3,r4,r5,LSR #16
;;;1263     
;;;1264     /* Get bit[23:0] of the flag */
;;;1265     I2C_IT &= FLAG_Mask;
000012  f021417f          BIC      r1,r1,#0xff000000
;;;1266   
;;;1267     /* Check the status of the specified I2C flag */
;;;1268     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000016  8a94              LDRH     r4,[r2,#0x14]
000018  400c              ANDS     r4,r4,r1
00001a  b114              CBZ      r4,|L17.34|
00001c  b10b              CBZ      r3,|L17.34|
;;;1269     {
;;;1270       /* I2C_IT is set */
;;;1271       bitstatus = SET;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L17.36|
                  |L17.34|
;;;1272     }
;;;1273     else
;;;1274     {
;;;1275       /* I2C_IT is reset */
;;;1276       bitstatus = RESET;
000022  2000              MOVS     r0,#0
                  |L17.36|
;;;1277     }
;;;1278     /* Return the I2C_IT status */
;;;1279     return  bitstatus;
;;;1280   }
000024  bd30              POP      {r4,r5,pc}
;;;1281   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1083     */
;;;1084   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;1085   {
000002  4601              MOV      r1,r0
;;;1086     uint32_t lastevent = 0;
000004  2000              MOVS     r0,#0
;;;1087     uint32_t flag1 = 0, flag2 = 0;
000006  2300              MOVS     r3,#0
000008  2200              MOVS     r2,#0
;;;1088   
;;;1089     /* Check the parameters */
;;;1090     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1091   
;;;1092     /* Read the I2Cx status register */
;;;1093     flag1 = I2Cx->SR1;
00000a  8a8b              LDRH     r3,[r1,#0x14]
;;;1094     flag2 = I2Cx->SR2;
00000c  8b0a              LDRH     r2,[r1,#0x18]
;;;1095     flag2 = flag2 << 16;
00000e  0412              LSLS     r2,r2,#16
;;;1096   
;;;1097     /* Get the last event value from I2C status register */
;;;1098     lastevent = (flag1 | flag2) & FLAG_Mask;
000010  ea430402          ORR      r4,r3,r2
000014  f024407f          BIC      r0,r4,#0xff000000
;;;1099   
;;;1100     /* Return status */
;;;1101     return lastevent;
;;;1102   }
000018  bd10              POP      {r4,pc}
;;;1103   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;830      */
;;;831    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;832    {
;;;833      /* Check the parameters */
;;;834      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;835      /* Return the selected I2C PEC value */
;;;836      return ((I2Cx->SR2) >> 8);
000002  8b08              LDRH     r0,[r1,#0x18]
000004  1200              ASRS     r0,r0,#8
;;;837    }
000006  4770              BX       lr
;;;838    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;550      */
;;;551    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;552    {
;;;553      /* Check the parameters */
;;;554      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;555      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;556      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;557      
;;;558      if (NewState != DISABLE)
;;;559      {
;;;560        /* Enable the selected I2C interrupts */
;;;561        I2Cx->CR2 |= I2C_IT;
000002  8883              LDRH     r3,[r0,#4]
000004  430b              ORRS     r3,r3,r1
000006  8083              STRH     r3,[r0,#4]
000008  e002              B        |L20.16|
                  |L20.10|
;;;562      }
;;;563      else
;;;564      {
;;;565        /* Disable the selected I2C interrupts */
;;;566        I2Cx->CR2 &= (uint16_t)~I2C_IT;
00000a  8883              LDRH     r3,[r0,#4]
00000c  438b              BICS     r3,r3,r1
00000e  8083              STRH     r3,[r0,#4]
                  |L20.16|
;;;567      }
;;;568    }
000010  4770              BX       lr
;;;569    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;196      */
;;;197    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;198    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;199      uint16_t tmpreg = 0, freqrange = 0;
00000a  2600              MOVS     r6,#0
00000c  46b1              MOV      r9,r6
;;;200      uint16_t result = 0x04;
00000e  2704              MOVS     r7,#4
;;;201      uint32_t pclk1 = 8000000;
000010  f8df80cc          LDR      r8,|L21.224|
;;;202      RCC_ClocksTypeDef  rcc_clocks;
;;;203      /* Check the parameters */
;;;204      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;205      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;206      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;207      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;208      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;209      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;210      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;211    
;;;212    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;213      /* Get the I2Cx CR2 value */
;;;214      tmpreg = I2Cx->CR2;
000014  88a6              LDRH     r6,[r4,#4]
;;;215      /* Clear frequency FREQ[5:0] bits */
;;;216      tmpreg &= CR2_FREQ_Reset;
000016  f64f70c0          MOV      r0,#0xffc0
00001a  4006              ANDS     r6,r6,r0
;;;217      /* Get pclk1 frequency value */
;;;218      RCC_GetClocksFreq(&rcc_clocks);
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       RCC_GetClocksFreq
;;;219      pclk1 = rcc_clocks.PCLK1_Frequency;
000022  f8dd8008          LDR      r8,[sp,#8]
;;;220      /* Set frequency bits depending on pclk1 value */
;;;221      freqrange = (uint16_t)(pclk1 / 1000000);
000026  482f              LDR      r0,|L21.228|
000028  fbb8f0f0          UDIV     r0,r8,r0
00002c  fa1ff980          UXTH     r9,r0
;;;222      tmpreg |= freqrange;
000030  ea460609          ORR      r6,r6,r9
;;;223      /* Write to I2Cx CR2 */
;;;224      I2Cx->CR2 = tmpreg;
000034  80a6              STRH     r6,[r4,#4]
;;;225    
;;;226    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;227      /* Disable the selected I2C peripheral to configure TRISE */
;;;228      I2Cx->CR1 &= CR1_PE_Reset;
000036  8820              LDRH     r0,[r4,#0]
000038  f64f71fe          MOV      r1,#0xfffe
00003c  4008              ANDS     r0,r0,r1
00003e  8020              STRH     r0,[r4,#0]
;;;229      /* Reset tmpreg value */
;;;230      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;231      tmpreg = 0;
000040  2600              MOVS     r6,#0
;;;232    
;;;233      /* Configure speed in standard mode */
;;;234      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000042  4929              LDR      r1,|L21.232|
000044  6828              LDR      r0,[r5,#0]
000046  4288              CMP      r0,r1
000048  d80c              BHI      |L21.100|
;;;235      {
;;;236        /* Standard mode speed calculate */
;;;237        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
00004a  6828              LDR      r0,[r5,#0]
00004c  0040              LSLS     r0,r0,#1
00004e  fbb8f0f0          UDIV     r0,r8,r0
000052  b287              UXTH     r7,r0
;;;238        /* Test if CCR value is under 0x4*/
;;;239        if (result < 0x04)
000054  2f04              CMP      r7,#4
000056  da00              BGE      |L21.90|
;;;240        {
;;;241          /* Set minimum allowed value */
;;;242          result = 0x04;  
000058  2704              MOVS     r7,#4
                  |L21.90|
;;;243        }
;;;244        /* Set speed value for standard mode */
;;;245        tmpreg |= result;	  
00005a  433e              ORRS     r6,r6,r7
;;;246        /* Set Maximum Rise Time for standard mode */
;;;247        I2Cx->TRISE = freqrange + 1; 
00005c  f1090001          ADD      r0,r9,#1
000060  8420              STRH     r0,[r4,#0x20]
000062  e027              B        |L21.180|
                  |L21.100|
;;;248      }
;;;249      /* Configure speed in fast mode */
;;;250      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;251      {
;;;252        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000064  88e8              LDRH     r0,[r5,#6]
000066  f64b71ff          MOV      r1,#0xbfff
00006a  4288              CMP      r0,r1
00006c  d106              BNE      |L21.124|
;;;253        {
;;;254          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;255          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
00006e  6828              LDR      r0,[r5,#0]
000070  eb000040          ADD      r0,r0,r0,LSL #1
000074  fbb8f0f0          UDIV     r0,r8,r0
000078  b287              UXTH     r7,r0
00007a  e009              B        |L21.144|
                  |L21.124|
;;;256        }
;;;257        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;258        {
;;;259          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;260          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
00007c  6828              LDR      r0,[r5,#0]
00007e  eb0001c0          ADD      r1,r0,r0,LSL #3
000082  eb011000          ADD      r0,r1,r0,LSL #4
000086  fbb8f0f0          UDIV     r0,r8,r0
00008a  b287              UXTH     r7,r0
;;;261          /* Set DUTY bit */
;;;262          result |= I2C_DutyCycle_16_9;
00008c  f4474780          ORR      r7,r7,#0x4000
                  |L21.144|
;;;263        }
;;;264    
;;;265        /* Test if CCR value is under 0x1*/
;;;266        if ((result & CCR_CCR_Set) == 0)
000090  f3c7000b          UBFX     r0,r7,#0,#12
000094  b908              CBNZ     r0,|L21.154|
;;;267        {
;;;268          /* Set minimum allowed value */
;;;269          result |= (uint16_t)0x0001;  
000096  f0470701          ORR      r7,r7,#1
                  |L21.154|
;;;270        }
;;;271        /* Set speed value and set F/S bit for fast mode */
;;;272        tmpreg |= (uint16_t)(result | CCR_FS_Set);
00009a  f4474000          ORR      r0,r7,#0x8000
00009e  4306              ORRS     r6,r6,r0
;;;273        /* Set Maximum Rise Time for fast mode */
;;;274        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
0000a0  f44f7096          MOV      r0,#0x12c
0000a4  fb09f000          MUL      r0,r9,r0
0000a8  f44f717a          MOV      r1,#0x3e8
0000ac  fb90f0f1          SDIV     r0,r0,r1
0000b0  1c40              ADDS     r0,r0,#1
0000b2  8420              STRH     r0,[r4,#0x20]
                  |L21.180|
;;;275      }
;;;276    
;;;277      /* Write to I2Cx CCR */
;;;278      I2Cx->CCR = tmpreg;
0000b4  83a6              STRH     r6,[r4,#0x1c]
;;;279      /* Enable the selected I2C peripheral */
;;;280      I2Cx->CR1 |= CR1_PE_Set;
0000b6  8820              LDRH     r0,[r4,#0]
0000b8  f0400001          ORR      r0,r0,#1
0000bc  8020              STRH     r0,[r4,#0]
;;;281    
;;;282    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;283      /* Get the I2Cx CR1 value */
;;;284      tmpreg = I2Cx->CR1;
0000be  8826              LDRH     r6,[r4,#0]
;;;285      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;286      tmpreg &= CR1_CLEAR_Mask;
0000c0  f64f30f5          MOV      r0,#0xfbf5
0000c4  4006              ANDS     r6,r6,r0
;;;287      /* Configure I2Cx: mode and acknowledgement */
;;;288      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;289      /* Set ACK bit according to I2C_Ack value */
;;;290      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000c6  88a8              LDRH     r0,[r5,#4]
0000c8  8969              LDRH     r1,[r5,#0xa]
0000ca  4308              ORRS     r0,r0,r1
0000cc  4306              ORRS     r6,r6,r0
;;;291      /* Write to I2Cx CR1 */
;;;292      I2Cx->CR1 = tmpreg;
0000ce  8026              STRH     r6,[r4,#0]
;;;293    
;;;294    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;295      /* Set I2Cx Own Address1 and acknowledged address */
;;;296      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000d0  89a8              LDRH     r0,[r5,#0xc]
0000d2  8929              LDRH     r1,[r5,#8]
0000d4  4308              ORRS     r0,r0,r1
0000d6  8120              STRH     r0,[r4,#8]
;;;297    }
0000d8  b005              ADD      sp,sp,#0x14
0000da  e8bd83f0          POP      {r4-r9,pc}
;;;298    
                          ENDP

0000de  0000              DCW      0x0000
                  |L21.224|
                          DCD      0x007a1200
                  |L21.228|
                          DCD      0x000f4240
                  |L21.232|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;701      */
;;;702    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;703    {
;;;704      /* Check the parameters */
;;;705      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;706      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;707      
;;;708      /* Check the input parameter */
;;;709      if (I2C_NACKPosition == I2C_NACKPosition_Next)
000004  d104              BNE      |L22.16|
;;;710      {
;;;711        /* Next byte in shift register is the last received byte */
;;;712        I2Cx->CR1 |= I2C_NACKPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L22.26|
                  |L22.16|
;;;713      }
;;;714      else
;;;715      {
;;;716        /* Current byte in shift register is the last received byte */
;;;717        I2Cx->CR1 &= I2C_NACKPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L22.26|
;;;718      }
;;;719    }
00001a  4770              BX       lr
;;;720    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;470      */
;;;471    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  460a              MOV      r2,r1
;;;472    {
;;;473      uint16_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;474    
;;;475      /* Check the parameters */
;;;476      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;477    
;;;478      /* Get the old register value */
;;;479      tmpreg = I2Cx->OAR2;
000004  8981              LDRH     r1,[r0,#0xc]
;;;480    
;;;481      /* Reset I2Cx Own address2 bit [7:1] */
;;;482      tmpreg &= OAR2_ADD2_Reset;
000006  f64f7301          MOV      r3,#0xff01
00000a  4019              ANDS     r1,r1,r3
;;;483    
;;;484      /* Set I2Cx Own address2 */
;;;485      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
00000c  f00203fe          AND      r3,r2,#0xfe
000010  4319              ORRS     r1,r1,r3
;;;486    
;;;487      /* Store the new register value */
;;;488      I2Cx->OAR2 = tmpreg;
000012  8181              STRH     r1,[r0,#0xc]
;;;489    }
000014  4770              BX       lr
;;;490    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;784      */
;;;785    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;786    {
;;;787      /* Check the parameters */
;;;788      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;789      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;790      if (I2C_PECPosition == I2C_PECPosition_Next)
000004  d104              BNE      |L24.16|
;;;791      {
;;;792        /* Next byte in shift register is PEC */
;;;793        I2Cx->CR1 |= I2C_PECPosition_Next;
000006  8802              LDRH     r2,[r0,#0]
000008  f4426200          ORR      r2,r2,#0x800
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L24.26|
                  |L24.16|
;;;794      }
;;;795      else
;;;796      {
;;;797        /* Current byte in shift register is PEC */
;;;798        I2Cx->CR1 &= I2C_PECPosition_Current;
000010  8802              LDRH     r2,[r0,#0]
000012  f24f73ff          MOV      r3,#0xf7ff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L24.26|
;;;799      }
;;;800    }
00001a  4770              BX       lr
;;;801    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;641      */
;;;642    uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;643    {
000002  4602              MOV      r2,r0
;;;644      __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;645    
;;;646      /* Check the parameters */
;;;647      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;648      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;649    
;;;650      tmp = (uint32_t) I2Cx;
000008  9200              STR      r2,[sp,#0]
;;;651      tmp += I2C_Register;
00000a  9800              LDR      r0,[sp,#0]
00000c  4408              ADD      r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;652    
;;;653      /* Return the selected register value */
;;;654      return (*(__IO uint16_t *) tmp);
000010  9800              LDR      r0,[sp,#0]
000012  8800              LDRH     r0,[r0,#0]
;;;655    }
000014  bd08              POP      {r3,pc}
;;;656    
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;588      */
;;;589    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;590    {
;;;591      /* Check the parameters */
;;;592      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;593      /* Return the data in the DR register */
;;;594      return (uint8_t)I2Cx->DR;
000002  8a08              LDRH     r0,[r1,#0x10]
000004  b2c0              UXTB     r0,r0
;;;595    }
000006  4770              BX       lr
;;;596    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;729      */
;;;730    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;731    {
;;;732      /* Check the parameters */
;;;733      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;734      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;735      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000004  d104              BNE      |L27.16|
;;;736      {
;;;737        /* Drive the SMBusAlert pin Low */
;;;738        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000006  8802              LDRH     r2,[r0,#0]
000008  f4425200          ORR      r2,r2,#0x2000
00000c  8002              STRH     r2,[r0,#0]
00000e  e004              B        |L27.26|
                  |L27.16|
;;;739      }
;;;740      else
;;;741      {
;;;742        /* Drive the SMBusAlert pin High  */
;;;743        I2Cx->CR1 &= I2C_SMBusAlert_High;
000010  8802              LDRH     r2,[r0,#0]
000012  f64d73ff          MOV      r3,#0xdfff
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L27.26|
;;;744      }
;;;745    }
00001a  4770              BX       lr
;;;746    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;606      */
;;;607    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L28.8|
;;;608    {
;;;609      /* Check the parameters */
;;;610      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;611      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;612      /* Test on the direction to set/reset the read/write bit */
;;;613      if (I2C_Direction != I2C_Direction_Transmitter)
;;;614      {
;;;615        /* Set the address bit0 for read */
;;;616        Address |= OAR1_ADD0_Set;
000002  f0410101          ORR      r1,r1,#1
000006  e002              B        |L28.14|
                  |L28.8|
;;;617      }
;;;618      else
;;;619      {
;;;620        /* Reset the address bit0 for write */
;;;621        Address &= OAR1_ADD0_Reset;
000008  f64f73fe          MOV      r3,#0xfffe
00000c  4019              ANDS     r1,r1,r3
                  |L28.14|
;;;622      }
;;;623      /* Send the address */
;;;624      I2Cx->DR = Address;
00000e  8201              STRH     r1,[r0,#0x10]
;;;625    }
000010  4770              BX       lr
;;;626    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;575      */
;;;576    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;577    {
;;;578      /* Check the parameters */
;;;579      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;580      /* Write in the DR register the data to be sent */
;;;581      I2Cx->DR = Data;
;;;582    }
000002  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;663      */
;;;664    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L30.12|
;;;665    {
;;;666      /* Check the parameters */
;;;667      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;668      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;669      if (NewState != DISABLE)
;;;670      {
;;;671        /* Peripheral under reset */
;;;672        I2Cx->CR1 |= CR1_SWRST_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4424200          ORR      r2,r2,#0x8000
000008  8002              STRH     r2,[r0,#0]
00000a  e003              B        |L30.20|
                  |L30.12|
;;;673      }
;;;674      else
;;;675      {
;;;676        /* Peripheral not under reset */
;;;677        I2Cx->CR1 &= CR1_SWRST_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f3c2020e          UBFX     r2,r2,#0,#15
000012  8002              STRH     r2,[r0,#0]
                  |L30.20|
;;;678      }
;;;679    }
000014  4770              BX       lr
;;;680    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;869      */
;;;870    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b921              CBNZ     r1,|L31.12|
;;;871    {
;;;872      /* Check the parameters */
;;;873      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;874      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;875      if (NewState == DISABLE)
;;;876      {
;;;877        /* Enable the selected I2C Clock stretching */
;;;878        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L31.22|
                  |L31.12|
;;;879      }
;;;880      else
;;;881      {
;;;882        /* Disable the selected I2C Clock stretching */
;;;883        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L31.22|
;;;884      }
;;;885    }
000016  4770              BX       lr
;;;886    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;303      */
;;;304    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;305    {
;;;306    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;307      /* initialize the I2C_ClockSpeed member */
;;;308      I2C_InitStruct->I2C_ClockSpeed = 5000;
000004  6001              STR      r1,[r0,#0]
;;;309      /* Initialize the I2C_Mode member */
;;;310      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;311      /* Initialize the I2C_DutyCycle member */
;;;312      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b71ff          MOV      r1,#0xbfff
00000e  80c1              STRH     r1,[r0,#6]
;;;313      /* Initialize the I2C_OwnAddress1 member */
;;;314      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  2100              MOVS     r1,#0
000012  8101              STRH     r1,[r0,#8]
;;;315      /* Initialize the I2C_Ack member */
;;;316      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000014  8141              STRH     r1,[r0,#0xa]
;;;317      /* Initialize the I2C_AcknowledgedAddress member */
;;;318      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000016  f44f4180          MOV      r1,#0x4000
00001a  8181              STRH     r1,[r0,#0xc]
;;;319    }
00001c  4770              BX       lr
;;;320    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;753      */
;;;754    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L33.12|
;;;755    {
;;;756      /* Check the parameters */
;;;757      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;758      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;759      if (NewState != DISABLE)
;;;760      {
;;;761        /* Enable the selected I2C PEC transmission */
;;;762        I2Cx->CR1 |= CR1_PEC_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f4425280          ORR      r2,r2,#0x1000
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L33.22|
                  |L33.12|
;;;763      }
;;;764      else
;;;765      {
;;;766        /* Disable the selected I2C PEC transmission */
;;;767        I2Cx->CR1 &= CR1_PEC_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f64e73ff          MOV      r3,#0xefff
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L33.22|
;;;768      }
;;;769    }
000016  4770              BX       lr
;;;770    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_i2c_c_7174d409____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_i2c_c_7174d409____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_i2c_c_7174d409____REVSH|
#line 144
|__asm___15_stm32f10x_i2c_c_7174d409____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
